# 題目一：解題說明


---

## 目錄
1. 答案展示
2. 解題思路
3. 解題優化
4. 總結

---

### 答案展示

基本答（時間複雜度：Big(O^2)）
*     路徑：App\Http\Controllers\Question1\Answer.php
![](https://i.imgur.com/Di2DL3Z.gif)

優化答（時間複雜度：Big（N））
*     路徑：App\Http\Controllers\Question1\Answer2.php
![](https://i.imgur.com/Kmt2EcP.gif)



---
### 解題思路
題目有N階樓梯，一次可以上1階或2階，共有幾種方法？
首先從已知方法找規律：
```
n=1, 1                                 = 1種
n=2, 1+1、2                            = 2種
n=3, 1+1+1、1+2、2+1                   = 3種
n=4, 1+1+1+1、1+1+2、1+2+1、2+1+1、2+2  = 5種
```

上面可以看到規律是一一
```
n=1, 1                                 
n=2, [1]+1、2                            
n=3, [1+1]+1、[2]+1、[1]+2  
n=4, [1+1+1]+1、[1+2]+1、[2+1]+1、[1+1]+2、[2]+2
```

上面規律用邏輯來說明就是一一我有四層階梯要走，這個時候我已經知道走兩層階梯有兩種方法，走三層階梯有三種方法，那麼我第一步先邁兩層，走到四層共兩種方法，然後加上我第一步先邁三層，走到四層共有三種方法，第一步不同最後到達的方法不同，所以是2種方法＋3種方法，共5種方法。

上述可以觀察出規則屬斐波那契數，於是可以用以下這個公式進行解題：**f[n]=f[n-1]+f[n-2]**

程式碼部分我們可以透過遞迴的概念，搭配斐波那契數撰寫如下：
![](https://i.imgur.com/VnMQxXn.png)


**最終計算結果:**

![](https://i.imgur.com/bccwsk1.png)


---
### 答案優化

在上述我們可以看到計算運行的次數是比較多的,且時間也較長。

**計算30層居然用了0.1秒，那麼如果300層不就需要1秒嗎？**

**這是錯的，因為時間複雜度是Big(o^2)**，是一個指數級別的算法，具體參考下圖：

![](https://i.imgur.com/weCQVMa.png)

從10層的0.00001秒到40層的24秒，**運算時間是百萬級的增長**。


那麼怎麼樣優化呢？來觀察一下斐波那契數一一
![](https://i.imgur.com/gJOJ5gV.png)


從裡面可以找出這個規律一一
![](https://i.imgur.com/vDWW8eL.png)

也就是說我們原本寫的程式因為Recursion（遞迴）的特性，會**不斷計算過重複計算過的值**，例如3樓共有5種方法，在上圖Tree中分為左右兩邊，明明是一樣的答案，但程式會分別運行一次，所以樓梯越長，Tree就長得越茂盛。

**如果只讓它運行一次呢？**

...

馬上實作！
![](https://i.imgur.com/syNpLSz.png)

...


**最終計算結果:**
![](https://i.imgur.com/Ucfhsm5.png)

可以看到再執行時間上有著極大幅度的改善，40層的樓梯僅用了0.0001秒！**算法的時間複雜度為BigO(N)**，轉為線性成長而非指數級的增長！


---
### 總結

優化答題中，透過空間換取時間的概念（因為空間越來越大，相較起CPU的算力更不值錢，很多時候要提升效率都是拿空間去換取的），去將時間複雜度從原本BigO(N^2) 優化成 BigO(N)級別！

（補充：未優化前的空間複雜度為BigO(1)、優化後的空間複雜度為BigO(N)）